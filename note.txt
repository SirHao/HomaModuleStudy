Notes for Homa implementation in Linux:
---------------------------------------
这个版本内核会报错,内存问题但本菜鸡不知道为啥
* Things to do:
  * Figure out socket locking disciplines.       找出socket locking规则
  * Many unimplemented interface functions.
  * Learn about CONFIG_COMPAT and whether it needs to be supported in
    struct proto and struct proto_ops.
    了解CONFIG_COMPAT以及是否需要在struct proto和struct proto_ops中支持它。
  * Learn about security stuff, and functions that need to be called for this.
    学习有关安全性的内容，以及为此需要调用的函数。
  * Learn about memory management for sk_buffs: how many is it OK to have?
    了解sk_buffs的内存管理:how many is it OK to have?
  * Initially using simple lists for all tables; will need to replace with
    something more efficient.
    所有的集合都是table，如何更高效（猜测打算用hash）
  * Eventually initialize homa.next_client_port to something random
    homa.next_client_port的初始化方法更随机而不是写死
  * homa_message_out_init: compute unscheduled bites and priority better.
    以后需要动态计算unscheduled bites和priority
  * Routes: what is the lifetime of these? How long can I retain a pointer?
    route的lifetime还没有考虑，以及后续如何维护

* Port numbers:
  * Shouldn't be visible to clients; only needed for servers.
    对于client来说不可见
  * Bind is only needed to receive requests.
    bind用来接收request
  * What if port space is partitioned?
    如果端口空间已被占用怎么办
    * 32 bits total
      总共占用32bit
    * Low-order 16 bits: server ports (bound)
      低16位：server端口（绑定）
    * Others: client ports
      高16位：client端口
      * Pick a random starting position on reboot 
        重新启动时(应该是重试？)随机选择一个起始位置
      * Allocate ports sequentially to mazimize time between reuse.
        顺序分配端口，以最大程度地延长两次重用(应该是冲突)之间的时间。
      * Or, just pick ports at random always (no predictability,
        better for security)?
        或者直接完全随机找端口？为了安全
    * Are FROM_CLIENT and FROM_SERVER needed still? Can deduce from
      the port numbers.
      是否仍然需要FROM_CLIENT和FROM_SERVER？ 可以从端口号推断出来。
    * A server will have 2 port numbers: one used for to receive requests
      and another to send requests.
      服务器将具有2个端口号：一个用于接收请求，另一个用于发送请求。

* On send:
  * Immediately copy message into sk_buffs.
    立即将消息复制到sk_buffs中
  * Client assigns message id; it's the first 8 bytes of the message data.
    客户分配消息ID； 它是消息数据的前8个字节
  * Return before sending entire message.
    在发送整个消息之前返回。
  * Homa keeps track of outstanding requests (some limit per socket?).
    Homa跟踪未完成的请求（每个套接字有一些限制吗？）
  * If message fails, kernel must fabricate a response. Perhaps all
    responses start with an id and a status?
    如果消息失败，内核必须构造响应。 也许所有响应都以id和状态开头？

* Tables needed:
  需要的集合梳理
  * All Homa sockets
    socket集合
    * Used to assign new port numbers
      用来分配新的port number
    * Used to dispatch incoming packets
      用来dispatch 接收的packet
    * Need RCU or some other kind of locking?
      需要RCU（Read-Copy Update 同步策略）或其他锁定策略
  * Outgoing RPCs (for a socket?)
    一个socket的rpcs table
    * Used to find state for incoming packets
      用来找到判断incoming packets的状态
    * Used for cleanup operations (socket closure, cancellation, etc.)
      用于清理操作（套接字关闭，取消等）
    * Used for detecting timeouts
      用来检测超时
    * No locks needed: use existing socket lock
      用现有的socket锁
    * Or, have one table for all sockets?
      或者搞成全局粒度？
  * Outgoing requests that haven't yet been transmitted:
    尚未发送的外发request：
    * For scheduling outbound traffic
      用于安排出站流量
    * Must be global?
      需要设置为global?
  * Outgoing responses that haven't yet been transmitted:
    尚未发送的外发response：
    * For scheduling outbound traffic
      用于安排出站流量
    * Must be global?
      需要设置为global?
  * Incoming RPCs:
    * Use to find state for incoming packets
      用来查找包的状态

* C++ data structures used in HomaTransport:
  * MessageAccumulator: std::vector of received packets, Buffer of
    assembled message
  * HomaTransport:
    * vectors of packets and messages
    * hash of outgoing RPCs
    * list of outgoing RPCs that haven't yet been transmitted
    * hash of incoming RPCs
    * list of RPCs that require timer attention
      需要计时器关注的RPC列表

* Miscellaneous information:
  * For raw sockets: "man 7 raw"  //链接：https://linux.die.net/man/7/raw

* What happens when a socket is closed?
  * socket.c:sock_close
    * socket.c:sock_release
      * proto_ops.release -> af_inet.c:inet_release)
      * af_inet.c:inet_release doesn't appear to do anything relevant to Homa
        * proto.close -> sock.c:sk_common_release?)
          * proto.unhash
          * sock_orphan
          * sock_put (decrements ref count, frees)

* What happens in a connect syscall (UDP)?
  * socket.c:sys_connect
    * proto_ops.connect -> af_inet.c:inet_dgram_connect
      * proto.connect -> datagram.c:ip4_datagram_connect
        * datagram.c: __ip4_datagram_connect

* What happens in a bind syscall (UDP)?
  * socket.c:sys_bind
    * proto_ops.bind -> afinet.c:inet_bind
      * proto.bind -> (not defined for UDP)
      * If no proto.bind handler, then a bunch of obscure -looking stuff
        happens.
      如果没有原型。绑定处理程序，然后会发生一堆看起来很模糊的事情

* What happens in a sendmsg syscall (UDP)?
  * socket.c:sys_sendmsg
    * socket.c:__sys_sendmsg
      * socket.c:___sys_sendmsg
        * Copy to msghdr and control info to kernel space
        * socket.c:sock_sendmsg
          * socket.c:sock_sendmsg_nosec
          * proto_ops.sendmsg -> afinet.c:inet_sendmsg
            * Auto-bind socket, if not bound
            * proto.sendmsg -> udp.c:udp_sendmsg
              * Long method ...
              * ip_output.c:ip_make_skb
                * Seems to collect data for the datagram?
                * __ip_append_data
              * udp.c:udp_send_skb
                * Creates UDP header
                * ip_output.c:ip_send_skb
                  * ip_local_out

============一些结构体
struct homa_client_rpc
    struct rpc_id id;                   //唯一id
    struct list_head client_rpcs_links; //link this -> homa_sock.client_rpcs.
    struct homa_message_out request;    //message request信息
        struct sk_buff_head packets; 
        struct sk_buff *next_packet; 
        //...unschedual byte ; priority 等参数


